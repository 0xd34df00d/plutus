(program
  (let
    (rec)
    (datatypebind
      (datatype
        (tyvardecl List (fun (type) (type)))
        (tyvardecl a (type))
        Nil_match
        (vardecl Nil [List a]) (vardecl Cons (fun a (fun [List a] [List a])))
      )
    )
    (let
      (nonrec)
      (datatypebind
        (datatype
          (tyvardecl AdditiveMonoid (fun (type) (type)))
          (tyvardecl a (type))
          AdditiveMonoid_match
          (vardecl
            CConsAdditiveMonoid
            (fun [(lam a (type) (fun a (fun a a))) a] (fun a [AdditiveMonoid a]))
          )
        )
      )
      (termbind
        (nonstrict)
        (vardecl fAdditiveMonoidInteger [AdditiveMonoid (con integer)])
        [
          [ { CConsAdditiveMonoid (con integer) } (builtin addInteger) ]
          (con integer 0)
        ]
      )
      (datatypebind
        (datatype
          (tyvardecl Monoid (fun (type) (type)))
          (tyvardecl a (type))
          Monoid_match
          (vardecl
            CConsMonoid
            (fun [(lam a (type) (fun a (fun a a))) a] (fun a [Monoid a]))
          )
        )
      )
      (datatypebind
        (datatype (tyvardecl Unit (type))  Unit_match (vardecl Unit Unit))
      )
      (let
        (rec)
        (termbind
          (nonstrict)
          (vardecl
            fFoldableNil_cfoldMap
            (all m (type) (all a (type) (fun [Monoid m] (fun (fun a m) (fun [List a] m)))))
          )
          (abs
            m
            (type)
            (abs
              a
              (type)
              (lam
                dMonoid
                [Monoid m]
                (let
                  (nonrec)
                  (termbind
                    (nonstrict)
                    (vardecl dSemigroup [(lam a (type) (fun a (fun a a))) m])
                    [
                      {
                        [ { Monoid_match m } dMonoid ]
                        [(lam a (type) (fun a (fun a a))) m]
                      }
                      (lam v [(lam a (type) (fun a (fun a a))) m] (lam v m v))
                    ]
                  )
                  (lam
                    ds
                    (fun a m)
                    (lam
                      ds
                      [List a]
                      [
                        [
                          [
                            { [ { Nil_match a } ds ] (fun Unit m) }
                            (lam
                              thunk
                              Unit
                              [
                                { [ { Monoid_match m } dMonoid ] m }
                                (lam
                                  v
                                  [(lam a (type) (fun a (fun a a))) m]
                                  (lam v m v)
                                )
                              ]
                            )
                          ]
                          (lam
                            x
                            a
                            (lam
                              xs
                              [List a]
                              (lam
                                thunk
                                Unit
                                [
                                  [ dSemigroup [ ds x ] ]
                                  [
                                    [
                                      [
                                        { { fFoldableNil_cfoldMap m } a }
                                        dMonoid
                                      ]
                                      ds
                                    ]
                                    xs
                                  ]
                                ]
                              )
                            )
                          )
                        ]
                        Unit
                      ]
                    )
                  )
                )
              )
            )
          )
        )
        [
          (let
            (nonrec)
            (termbind
              (strict)
              (vardecl dAdditiveMonoid [AdditiveMonoid (con integer)])
              fAdditiveMonoidInteger
            )
            [
              [
                {
                  { fFoldableNil_cfoldMap [(lam a (type) a) (con integer)] }
                  (con integer)
                }
                [
                  [
                    { CConsMonoid [(lam a (type) a) (con integer)] }
                    (lam
                      eta
                      [(lam a (type) a) (con integer)]
                      (lam
                        eta
                        [(lam a (type) a) (con integer)]
                        [
                          [
                            [
                              {
                                [
                                  { AdditiveMonoid_match (con integer) }
                                  dAdditiveMonoid
                                ]
                                [(lam a (type) (fun a (fun a a))) (con integer)]
                              }
                              (lam
                                v
                                [(lam a (type) (fun a (fun a a))) (con integer)]
                                (lam v (con integer) v)
                              )
                            ]
                            eta
                          ]
                          eta
                        ]
                      )
                    )
                  ]
                  [
                    {
                      [ { AdditiveMonoid_match (con integer) } dAdditiveMonoid ]
                      (con integer)
                    }
                    (lam
                      v
                      [(lam a (type) (fun a (fun a a))) (con integer)]
                      (lam v (con integer) v)
                    )
                  ]
                ]
              ]
              (lam v (con integer) v)
            ]
          )
          [
            (let
              (nonrec)
              (termbind
                (strict)
                (vardecl
                  c
                  (fun (con integer) (fun [List (con integer)] [List (con integer)]))
                )
                { Cons (con integer) }
              )
              (lam
                n
                [List (con integer)]
                [
                  [ c (con integer 1) ]
                  [
                    [ c (con integer 2) ]
                    [ [ c (con integer 3) ] [ [ c (con integer 4) ] n ] ]
                  ]
                ]
              )
            )
            { Nil (con integer) }
          ]
        ]
      )
    )
  )
)